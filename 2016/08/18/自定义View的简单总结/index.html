<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>自定义View的简单总结 | Coding Life</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[TOC]
自定义 View 的简单总结
虽然Android中已经提供了很多控件，但是在实际的开发工作中，很可能需要一些系统内置的控件满足不了的特殊需求，这时就需要自定义实现一些特定功能的 View。

初识 ViewRoot 和 DecorView正式介绍 View 的三大流程之前，我们必须先介绍一些基本概念，这样才能更好的理解View的 measure，layout和draw过程。
​">
<meta property="og:type" content="article">
<meta property="og:title" content="自定义View的简单总结">
<meta property="og:url" content="http://yoursite.com/2016/08/18/自定义View的简单总结/index.html">
<meta property="og:site_name" content="Coding Life">
<meta property="og:description" content="[TOC]
自定义 View 的简单总结
虽然Android中已经提供了很多控件，但是在实际的开发工作中，很可能需要一些系统内置的控件满足不了的特殊需求，这时就需要自定义实现一些特定功能的 View。

初识 ViewRoot 和 DecorView正式介绍 View 的三大流程之前，我们必须先介绍一些基本概念，这样才能更好的理解View的 measure，layout和draw过程。
​">
<meta property="og:image" content="http://yoursite.com/Users/hywel/Desktop/view_mechanism_flow.png">
<meta property="og:image" content="http://yoursite.com/Users/hywel/Desktop/View travelsals.png">
<meta property="og:image" content="http://yoursite.com/Users/hywel/Desktop/DecorView.png">
<meta property="og:image" content="http://yoursite.com/Users/hywel/Desktop/view_draw_flow.jpg">
<meta property="og:image" content="http://yoursite.com/Users/hywel/Desktop/005Xtdi2jw1f638wreu74j30fc0heaay.jpg">
<meta property="og:image" content="http://yoursite.com/Users/hywel/Desktop/005Xtdi2jw1f1qygzfvhoj308c0dwglr.jpg">
<meta property="og:image" content="http://yoursite.com/Users/hywel/Desktop/005Xtdi2jw1f1qyhjy7h8j308c0dwq32.jpg">
<meta property="og:image" content="http://yoursite.com/Users/hywel/Desktop/005Xtdi2gw1f1qzqwvkkbj308c0dwgm9.jpg">
<meta property="og:image" content="http://yoursite.com/Users/hywel/Desktop/005Xtdi2jw1f1r2bdlqhbj308c0dwwew.jpg">
<meta property="og:image" content="http://yoursite.com/Users/hywel/Desktop/CustomView.png">
<meta property="og:updated_time" content="2017-01-07T14:40:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="自定义View的简单总结">
<meta name="twitter:description" content="[TOC]
自定义 View 的简单总结
虽然Android中已经提供了很多控件，但是在实际的开发工作中，很可能需要一些系统内置的控件满足不了的特殊需求，这时就需要自定义实现一些特定功能的 View。

初识 ViewRoot 和 DecorView正式介绍 View 的三大流程之前，我们必须先介绍一些基本概念，这样才能更好的理解View的 measure，layout和draw过程。
​">
<meta name="twitter:image" content="http://yoursite.com/Users/hywel/Desktop/view_mechanism_flow.png">
  
    <link rel="alternate" href="/atom.xml" title="Coding Life" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="http://fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Coding Life</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">风在水墨里拂柳 云在油彩里飘柔</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">目录</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
  <script>
    
    document.getElementById("banner").style.backgroundImage = "url(/css/images/banner.jpg)";
    
</script>
</header>
      <div class="outer">
        <section id="main"><article id="post-自定义View的简单总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/18/自定义View的简单总结/" class="article-date">
  <time datetime="2016-08-18T09:10:21.000Z" itemprop="datePublished">2016-08-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/coding/">coding</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      自定义View的简单总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="自定义-View-的简单总结"><a href="#自定义-View-的简单总结" class="headerlink" title="自定义 View 的简单总结"></a>自定义 View 的简单总结</h1><blockquote>
<p>虽然Android中已经提供了很多控件，但是在实际的开发工作中，很可能需要一些系统内置的控件满足不了的特殊需求，这时就需要自定义实现一些特定功能的 View。</p>
</blockquote>
<h2 id="初识-ViewRoot-和-DecorView"><a href="#初识-ViewRoot-和-DecorView" class="headerlink" title="初识 ViewRoot 和 DecorView"></a>初识 ViewRoot 和 DecorView</h2><p>正式介绍 View 的三大流程之前，我们必须先介绍一些基本概念，这样才能更好的理解View的 measure，layout和draw过程。</p>
<p>​    ViewRoot 对应于ViewRootImpl 类，它是连接WindowManager 和DecorView的纽带，它并不是一个 View 类型，而是一个 Handler。它的主要作用有两点：</p>
<ol>
<li>向DecorView分发收到的用户发起的event事件，如按键，触屏，轨迹球等事件；</li>
<li>与WindowManagerService交互，完成整个Activity的GUI的绘制。</li>
</ol>
<p>View 的三大流程均是通过 ViewRoot来完成的。在 ActivityThread 中，当 Activity 对象被创建完毕后，会将 DecorView 添加到 Window 中，同时会创建 ViewRootImpl 对象，并将ViewRootImpl对象和 DecorView建立关联，这个过程可以参看如下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext(),display);</div><div class="line">root.setView(view,wparams,panelParentView);</div></pre></td></tr></table></figure>
<p>​    <a id="more"></a></p>
<p>​    View 的绘制流程是从 ViewRoot 的 performTraversals 方法开始的，它经过 measure,layout和 draw 三个过程才能最终将一个 View 绘制出来的，其中 measure 用来测量 View的宽和高，layout 用来确定 View 在父容器中的放置位置，而 draw 则负责将 View 绘制在屏幕上。针对 performTraversals 的大致流程，用流程图表示如下：</p>
<p>  <img src="/Users/hywel/Desktop/view_mechanism_flow.png" alt="view_mechanism_flow"></p>
<p><strong>View 绘制流程的函数调用链</strong></p>
<p>  <img src="/Users/hywel/Desktop/View travelsals.png" alt="View travelsals"></p>
<p>performTraversals 会依次调用 performMeasure,performLayout和 performDraw 三个方法，这三个方法分别完成顶级 View的 measure，layout 和 draw这三大流程，其中 performMeasure 中会调用 measure 方法，在 measure 方法中又会调用 onMeasure 方法，在 onMeasure 方法中则会对所有的子元素进行 measure 过程，这个时候 measure 流程就从父容器传递到子元素中了，这样就完成了一次measure 过程。接着子元素会重复父容器的 measure 过程，如此反复就完成了整个 View 树的遍历。同理，performLayout 和 performDraw 的传递流程和 performMeasure 是类似的，唯一不同的是，performDraw 的传递过程是在 draw 方法中通过 dispatchDraw 来实现的，不过这并没有本质区别。</p>
<p>​    measure 过程决定了 View 的宽/高，Measure 完成以后，通过 getMeasuredWidth 和 getMeasuredHeight 方法来获取到 View 测量后的宽/高。Layout 过程决定了View 的四个顶点的坐标和实际View 的宽/高，完成以后，可以通过 getTop，getBottom，getLeft和 getRight 来拿到 View 的四个顶点的位置，用可以通过 getWidth 和 getHeight 方法来拿到 View 的最终宽/高。Draw 过程则决定了 View 的显示，只有draw 方法完成之后 View 的内容才可以呈现在屏幕上。</p>
<p><strong>DecorView的结构</strong></p>
<p> <img src="/Users/hywel/Desktop/DecorView.png" alt="DecorView"></p>
<blockquote>
<p>DecorView是顶级View，内部有TitleBar和mContentParent两个子元素，mContentParent的id是content，而我们设置的main.xml布局则是contentParent里面的一个子元素。</p>
</blockquote>
<p>​    DecorView作为 Window 界面的最顶层 View，一般会包含一个竖直方向的 LinearLayout，代表整个Window界面，包含通知栏，标题栏，内容显示栏三块区域。LinearLayout里包含两个 FrameLayout，一个是标题栏显示界面。另一个是内容栏显示界面，就是通过 setContentView 方法载入的布局界面。通过源码可以知道，DecorView 其实是一个 FrameLayout，View 层的事件都先经过 DecorView,然后才传递给我们的 View。</p>
<h2 id="理解-MeasureSpec"><a href="#理解-MeasureSpec" class="headerlink" title="理解 MeasureSpec"></a>理解 MeasureSpec</h2><p>为了更好的理解 View 的测量过程，我们还需要理解 MeasureSpec。</p>
<p>MeasureSpec 代表一个32位的 int 值，高2位代表 SpecMode，低30位代表 SpecSize。SpecMode是指测量模式，而SpecSize是指在某种测量模式下的规格大小。可以看下MeasureSpec的部分代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</div><div class="line"><span class="comment">/**</span></div><div class="line">* Creates a measure specification based on the supplied size and mode.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</div><div class="line">                <span class="keyword">return</span> size + mode;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</div><div class="line">            &#125;</div><div class="line"> 	&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Extracts the mode from the supplied measure specification.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</div><div class="line">	&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Extracts the size from the supplied measure specification.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>​    MeasureSpec通过将 SpecMode 和 SpecSize 打包成一个 int 值来避免过多的对象内存分配。SpecMode 和 SpecSize 也是一个 int 值，一组SpecMode 和 SpecSize 可以打包为一个 MeasureSpec，而一个MeasureSpec可以通过解包的形式得出其原始的SpecMode 和 SpecSize。这里的 MeasureSpec 只是 MeasureSpec 所代表的 int 值，而并非 MeasureSpec 本身。</p>
<p>​    SpecMode 有三类，每一类都表示特殊的含义。如下：</p>
<ul>
<li><p>UNSPECIFIED</p>
<p>​父容器不对 View 有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。</p>
</li>
<li><p>EXACTLY</p>
<p>​父容器已经检测出 View 所需要的精确大小，这个时候 View 的最终大小就是 SpecSize 所指定的值。它对应于 LayouParams 中的 match_parent 和具体的数值这两种模式。</p>
</li>
<li><p>AT_MOST</p>
<p>​父容器指定了一个可用大小即 SpecSize，View 的大小不能大于这个值，具体值则要看不同 View 的具体表现，它对应于 LayoutParams 中的 wrap_content。</p>
</li>
</ul>
<h2 id="View-的区别：View，ViewGroup"><a href="#View-的区别：View，ViewGroup" class="headerlink" title="View 的区别：View，ViewGroup"></a>View 的区别：View，ViewGroup</h2><p>Android View和ViewGroup从组成架构上看，似乎ViewGroup在View之上，View需要继承ViewGroup，但实际上不是这样的。<strong>View是基类，ViewGroup是它的子类。</strong>这就证明了一点，View代表了用户界面组件的一块可绘制的空间块。每一个View在屏幕上占据一个长方形区域。在这个区域内，这个VIEW对象负责图形绘制和事件处理。View是小控件widgets和ViewGroup的父类。ViewGroup又是Layout的基类。在 Android 中，视图控件大致可以分为两类，即 ViewGroup 和 View，<strong>通过ViewGroup和View便形成了控件树，各个ViewGoup对象和View对象就是控件树中的节点。</strong>在控件树中，以树的深度来遍历查找对应的控件元素，同时，上层控件负责子控件的测量与绘制，并传递交互事件。</p>
<p>一般来说，开发Android应用程序的UI界面都不会直接实用View和ViewGroup，而是使用这两大基类的派生类。</p>
<ul>
<li>View 派生出的直接子类有：AnalogClock,ImageView,KeyboardView,ProgressBar,SurfaceView,TextView,ViewGroup,ViewStub等</li>
</ul>
<ul>
<li><p>View 派生出的间接子类有：</p>
<p>AbsListView,AbsSeekBar,AbsSpinner, AbsoluteLayout, AdapterView<strong><t extends="" adapter=""></t></strong>,AdapterViewAnimator, AdapterViewFlipper, AppWidgetHostView, AutoCompleteTextView,Button,CalendarView, CheckBox, CheckedTextView, Chronometer, CompoundButton等</p>
</li>
</ul>
<ul>
<li>ViewGroup派生出的直接子类有：AbsoluteLayout,AdapterView<strong><t extends="" adapter=""></t></strong>,FragmentBreadCrumbs,FrameLayout,LinearLayout,RelativeLayout,SlidingDrawer等</li>
</ul>
<ul>
<li><p>ViewGroup派生出的间接子类有：</p>
<p>AbsListView,AbsSpinner, AdapterViewAnimator, AdapterViewFlipper, AppWidgetHostView, CalendarView, DatePicker, DialerFilter, ExpandableListView, Gallery, GestureOverlayView,GridView,HorizontalScrollView, ImageSwitcher,ListView等</p>
</li>
</ul>
<p>上述的所有基类、派生类都是Android framework层集成的标准系统类，开发者在应用开发中可直接引用SDK中这些系统类及其API。但事实上，在UI开发的很多场景下，直接使用这些系统类并不能满足应用开发的需要。比如说，我们想用ImageView在默认情况下加载一幅图片，但是希望在点击该View时View变换出各种图像处理效果，这个时候直接使用ImageView是不行的，此时我们可以重载ImageView，在新派生出的子控件中重载OnDraw等方法来实现我们的定制效果。这种派生出系统类的子类方法我们通常称之为自定义控件。</p>
<h2 id="View-的几个构造方法"><a href="#View-的几个构造方法" class="headerlink" title="View 的几个构造方法"></a>View 的几个构造方法</h2><p>View的构造函数有四种重载分别如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">VolumeView</span><span class="params">(Context context)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">VolumeView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">VolumeView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">VolumeView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>可以看出，关于 View 构造函数的参数有多有少，我们着重研究。</p>
<p><strong>有四个参数的构造函数在 API12的时候才增加，暂不考虑</strong></p>
<p>有三个参数的构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，且只有在明确调用的时候才会生效，以系统中的ImageButton为例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageButton</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="comment">//调用了三个参数的构造函数，明确指定第三个参数</span></div><div class="line">		<span class="keyword">this</span>(context, attrs,        com.android.internal.R.attr.imageButtonStyle);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageButton</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">        <span class="comment">//此处调了四个参数的构造函数，无视即可</span></div><div class="line">        <span class="keyword">this</span>(context, attrs, defStyleAttr, <span class="number">0</span>); </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>注意：即使你在View中使用了Style这个属性也不会调用三个参数的构造函数，所调用的依旧是两个参数的构造函数。</strong></p>
<p><strong>由于三个参数的构造函数第三个参数一般不用，暂不考虑。</strong></p>
<p>在实际自定义 View 的开发工作中，最经常用到的是两个参数的构造函数。在这个构造函数里做一些初始化工作，例如初始化画笔、引入和绑定属性等。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">VolumeView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        setAttrs(context, attrs);<span class="comment">//设置属性</span></div><div class="line">        initPaint();<span class="comment">//初始化画笔</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">     * 获取自定义View的属性值</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> context</div><div class="line">     * <span class="doctag">@param</span> attrs</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAttrs</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.VolumeView);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != a) &#123;</div><div class="line">            radius = a.getDimensionPixelSize(R.styleable.VolumeView_radius, defaultRadius);</div><div class="line">            backgroundColor = a.getColor(R.styleable.VolumeView_backgroundColor,</div><div class="line">                    defaultBackgroundColor);</div><div class="line">            volumeColor = a.getColor(R.styleable.VolumeView_volumeColor, defaultVolumeColor);</div><div class="line">            primaryVolumeColor = a.getColor(R.styleable.VolumeView_primaryVolumeColor,</div><div class="line">                    defaultPrimaryVolumeColor);</div><div class="line">            borderWidth = a.getDimensionPixelSize(R.styleable.VolumeView_borderWidth,</div><div class="line">                    defaultBorderWidth);</div><div class="line">            maxVolume = a.getInt(R.styleable.VolumeView_maxVolume, <span class="number">15</span>);</div><div class="line">            a.recycle();</div><div class="line">        &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">     * 初始化画笔</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPaint</span><span class="params">()</span> </span>&#123;</div><div class="line">        angle = <span class="number">360f</span> / maxVolume;</div><div class="line">        unitAngle = angle / maxAnimationValue;</div><div class="line">        paint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">        paint.setAntiAlias(<span class="keyword">true</span>);<span class="comment">//抗锯齿</span></div><div class="line">        paint.setDither(<span class="keyword">true</span>);<span class="comment">//防抖</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="View-的工作流程"><a href="#View-的工作流程" class="headerlink" title="View 的工作流程"></a>View 的工作流程</h2><p>View 工作流程的调用链：</p>
<p> <img src="/Users/hywel/Desktop/view_draw_flow.jpg" alt="view_draw_flow"></p>
<p>​    View 的工作流程主要指的是 measure，layout，draw 这三大流程，即测量，布局，绘制。其中measure 确定 View 的测量宽/高，layout 确定 View 的最终宽/高和四个顶点的位置，而 draw 则将 View 绘制到屏幕上。</p>
<h3 id="View-的-measure-过程"><a href="#View-的-measure-过程" class="headerlink" title="View 的 measure 过程"></a>View 的 measure 过程</h3><p>View 的 measure 过程由其 measure 方法来完成，measure 方法是一个 final 类型的方法，故子类不能重写该方法，在 View 的 measure 方法中会去调用 View 的 onMeasure 方法，因此只需要看 onMeasure 的实现即可，View 的 onMeasure 方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">      setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>setMeasuredDimension方法会设置 View 的宽/高的测量值，因此我们只需要看 getDefaultSize 这个方法即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = size;</div><div class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (specMode) &#123;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">            result = size;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>此方法逻辑简单，先看 <code>AT_MOST</code> 和<code>EXACTLY</code> 这两种情况。简单来理解，此方法返回的大小就是 MeasureSpec 中的 Specsize，而这个 Specsize 就是 View测量后的大小，这里多次提到测量后的大小，是因为View 最终的大小是在 layout 阶段确定的，所以这里必须要加以区分，但是几乎所有情况下 View 的测量大小和最终大小是相等的。</p>
<p><code>UNSPECIFIED</code>这种情况，一般用于系统内部的测量过程，这种情况下，View 的大小为 getDefaultSize 的第一个参数 size，即宽/高分别为getSuggestedMinimumWidth 和 getSuggestedMinimumHeight 这两个方法的返回值。</p>
<h3 id="ViewGroup-的-measure-过程"><a href="#ViewGroup-的-measure-过程" class="headerlink" title="ViewGroup 的 measure 过程"></a>ViewGroup 的 measure 过程</h3><p>对于ViewGroup来说，除了完成自己的 measure 过程外还会遍历调用所有子元素的 measure 方法，各个子元素再递归去执行这个过程。和 View 不同的是，ViewGroup是一个抽象类，因此它没有重写 View 的 onMeasure 方法，但是它提供了一个叫 measureChild 的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">        <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">            <span class="keyword">final</span> View child = children[i];</div><div class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看出，ViewGroup 在 measure 时，会对每一个子元素进行 measure，measureChild 这个方法的实现也很好理解，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line"><span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">        <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom, lp.height);</div><div class="line"></div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>也很显然，measureChild 的意思就是取出子元素的 LayoutParams，然后通过getChildMeasureSpec来创建子元素的 MeasureSpec，接着 MeasureSpec 直接传递给 View 的 measure 方法来进行测量。ViewGroup 没有定义其测量的具体过程，因为 ViewGroup 是一个抽象类， 其测量过程的 onMeasure 方法需要各个子类去具体实现。</p>
<h3 id="layout-过程"><a href="#layout-过程" class="headerlink" title="layout 过程"></a>layout 过程</h3><p>Layout 的作用是 ViewGroup 用来确定子元素的位置，当 ViewGroup 的位置被确定后，它在 onLayout 中会遍历所有的子元素并确定其 layout 方法，在 layout 方法中 onLayout方法又会被调用。Layout 过程和 measure 过程相比就简单多了，layout 方法确定 View本身的位置，而 onLayout 方法则会确定所有子元素的位置，View 的 layout 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">            onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> oldL = mLeft;</div><div class="line">        <span class="keyword">int</span> oldT = mTop;</div><div class="line">        <span class="keyword">int</span> oldB = mBottom;</div><div class="line">        <span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">                ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">                        (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">                <span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">                    listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">        mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>layout的大致流程如下：首先会通过 setFrame 方法来设定 View 的四个顶点的位置，这样 View在父容器的位置也就确定了；接着会调用 onLayout 方法，这个方法的用途是父容器确定子元素的位置，和 onMeasure 方法类似，onLayout 的具体实现同样和具体的布局有关，所以 View 和 ViewGroup 均没有真正实现 onLayout 方法。</p>
<h3 id="draw-过程"><a href="#draw-过程" class="headerlink" title="draw 过程"></a>draw 过程</h3><p>Draw 过程就比较简单了，它的作用是将 View 绘制到屏幕上面，View 的绘制过程遵循如下几步：</p>
<ol>
<li>绘制背景 background.draw(canvas)</li>
<li>绘制自己 (onDraw)</li>
<li>绘制 children (dispatchDraw)</li>
<li>绘制装饰 (onDrawScrollBars)</li>
</ol>
<h2 id="View绘制中的几个重要方法"><a href="#View绘制中的几个重要方法" class="headerlink" title="View绘制中的几个重要方法"></a>View绘制中的几个重要方法</h2><ul>
<li>onSizeChanged()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>这个方法在界面的尺寸更改的时候会被调用，一般是在屏幕旋转的时候会被调用，有两个新w/h和旧w/h会被传入。</p>
<ul>
<li>onMeasure()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Called to determine the size requirements for this view and all of its children.</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">   setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">   getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p><strong>CONTRACT</strong>: When overriding this method, you must call setMeasuredDimension(int, int) to store </p>
<p><em>当重写此方法时，必须要调用setMeasuredDimension(int, int)来存储</em></p>
<p>the measured width and height of this view. Failure to do so will trigger an IllegalStateException, </p>
<p><em>已经测量好的视图的宽和高，否则会由此触发IllegalStateException，</em></p>
<p>thrown by measure(int, int). Calling the superclass’ onMeasure(int, int) is a valid use.</p>
<p><em>同样调用父类的 onMeasure(int, int) 也是可以的。</em></p>
<p>onMeasure()方法顾名思义就是用于测量视图的大小的。measure()方法接收两个参数，widthMeasureSpec和heightMeasureSpec，这两个值分别用于确定视图的宽度和高度的规格和大小。</p>
<p>MeasureSpec的值由specSize和specMode共同组成的，其中specSize记录的是大小，specMode记录的是规格。specMode一共有三种类型，如下所示：</p>
<ul>
<li>EXACTLY</li>
</ul>
<p>​表示父视图希望子视图的大小应该是由specSize的值来决定的，系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。</p>
<ul>
<li>AT_MOST</li>
</ul>
<p>​表示子视图最多只能是specSize中指定的大小，开发人员应该尽可能少得去设置这个视图，并且保证不会超过specSize。系统默认会按照这个规则来设置子视图的大小，开发人员当然也可以按照自己的意愿设置成任意的大小。</p>
<ul>
<li>UNSPECIFIED</li>
</ul>
<p>表示开发人员可以将视图按照自己的意愿设置成任意的大小，没有任何限制。这种情况比较少见，不太会用到。通常情况下，<strong>widthMeasureSpec</strong>和<strong>heightMeasureSpec</strong>两个值都是由父视图经过计算后传递给子视图的，说明父视图会在一定程度上决定子视图的大小。但是最外层的根视图，它的widthMeasureSpec和heightMeasureSpec又是从哪里得到的呢？这就需要去分析ViewRoot中的源码了，观察performTraversals()方法可以发现如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</div><div class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</div></pre></td></tr></table></figure>
<p>可以看到，这里调用了getRootMeasureSpec()方法去获取widthMeasureSpec和heightMeasureSpec的值，注意方法中传入的参数，其中lp.width和lp.height在创建ViewGroup实例的时候就被赋值了，它们都等于MATCH_PARENT。然后看下getRootMeasureSpec()方法中的代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> measureSpec;</div><div class="line">	<span class="keyword">switch</span> (rootDimension) &#123;</div><div class="line">	<span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">		measureSpec = MeasureSpec.makeMeasureSpec(windowSize, 			MeasureSpec.EXACTLY);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">		measureSpec = MeasureSpec.makeMeasureSpec(windowSize, 			MeasureSpec.AT_MOST);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, 			MeasureSpec.EXACTLY);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> measureSpec;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用了MeasureSpec.makeMeasureSpec()方法来组装一个MeasureSpec，当rootDimension参数等于MATCH_PARENT的时候，MeasureSpec的specMode就等于EXACTLY，当rootDimension等于WRAP_CONTENT的时候，MeasureSpec的specMode就等于AT_MOST。并且MATCH_PARENT和WRAP_CONTENT时的specSize都是等于windowSize的，也就意味着根视图总是会充满全屏的。</p>
<p>接下来我们看下View的measure()方法里面的代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> ((mPrivateFlags &amp; FORCE_LAYOUT) == FORCE_LAYOUT ||</div><div class="line">	widthMeasureSpec != mOldWidthMeasureSpec ||</div><div class="line">	heightMeasureSpec != mOldHeightMeasureSpec) &#123;</div><div class="line">	mPrivateFlags &amp;= ~MEASURED_DIMENSION_SET;</div><div class="line">	<span class="keyword">if</span> (ViewDebug.TRACE_HIERARCHY) &#123;</div><div class="line">		ViewDebug.trace(<span class="keyword">this</span>, 	ViewDebug.HierarchyTraceType.ON_MEASURE);</div><div class="line">	&#125;</div><div class="line">	onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">	<span class="keyword">if</span> ((mPrivateFlags &amp; MEASURED_DIMENSION_SET) != 			MEASURED_DIMENSION_SET) &#123;</div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"onMeasure() did not set the"</span></div><div class="line">	+ <span class="string">" measured dimension by calling"</span></div><div class="line">	+ <span class="string">" setMeasuredDimension()"</span>);</div><div class="line">&#125;</div><div class="line">	mPrivateFlags |= LAYOUT_REQUIRED;</div><div class="line">&#125;</div><div class="line">	mOldWidthMeasureSpec = widthMeasureSpec;</div><div class="line">	mOldHeightMeasureSpec = heightMeasureSpec;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意观察，measure()这个方法是final的，因此我们无法在子类中去重写这个方法，说明Android是不允许我们改变View的measure框架的。然后在第9行调用了onMeasure()方法，这里才是真正去测量并设置View大小的地方，默认会调用getDefaultSize()方法来获取视图的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> result = size;</div><div class="line">	<span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">	<span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</div><div class="line">	<span class="keyword">switch</span> (specMode) &#123;</div><div class="line">	<span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">		result = size;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> MeasureSpec.AT_MOST:</div><div class="line">	<span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">		result = specSize;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里传入的measureSpec是一直从measure()方法中传递过来的。然后调用MeasureSpec.getMode()方法可以解析出specMode，调用MeasureSpec.getSize()方法可以解析出specSize。接下来进行判断，如果specMode等于AT_MOST或EXACTLY就返回specSize，这也是系统默认的行为。之后会在onMeasure()方法中调用setMeasuredDimension()方法来设定测量出的大小，这样一次measure过程就结束了。</p>
<p>当然，一个界面的展示可能会涉及到很多次的measure，因为一个布局中一般都会包含多个子视图，每个视图都需要经历一次measure过程。ViewGroup中定义了一个measureChildren()方法来去测量子视图的大小，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</div><div class="line">	<span class="keyword">final</span> View[] children = mChildren;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</div><div class="line">		<span class="keyword">final</span> View child = children[i];</div><div class="line">		<span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">		measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里首先会去遍历当前布局下的所有子视图，然后逐个调用measureChild()方法来测量相应子视图的大小，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></div><div class="line"><span class="keyword">int</span> parentHeightMeasureSpec) &#123;</div><div class="line">	<span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = 									getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">		mPaddingLeft + mPaddingRight, lp.width);</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = 									getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">		mPaddingTop + mPaddingBottom, lp.height);</div><div class="line">		child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在第4行和第6行分别调用了getChildMeasureSpec()方法来去计算子视图的MeasureSpec，计算的依据就是布局文件中定义的MATCH_PARENT、WRAP_CONTENT等值，这个方法的内部细节就不再贴出。然后在第8行调用子视图的measure()方法，并把计算出的MeasureSpec传递进去，之后的流程就和前面所介绍的一样了。<br>当然，onMeasure()方法是可以重写的，也就是说，如果你不想使用系统默认的测量方式，可以按照自己的意愿进行定制，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line"></div><div class="line">	......</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">		setMeasuredDimension(<span class="number">200</span>, <span class="number">200</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话就把View默认的测量流程覆盖掉了，不管在布局文件中定义MyView这个视图的大小是多少，最终在界面上显示的大小都将会是200*200。</p>
<p>需要注意的是，在setMeasuredDimension()方法调用之后，我们才能使用getMeasuredWidth()和getMeasuredHeight()来获取视图测量出的宽高，以此之前调用这两个方法得到的值都会是0。</p>
<p>由此可见，视图大小的控制是由父视图、布局文件、以及视图本身共同完成的，父视图会提供给子视图参考的大小，而开发人员可以在XML文件中指定视图的大小，然后视图本身会对最终的大小进行拍板。</p>
<ul>
<li>onLayout()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>measure过程结束后，视图的大小就已经测量好了，接下来就是layout的过程了。正如其名字所描述的一样，这个方法是用于给视图进行布局的，也就是确定视图的位置。ViewRoot的performTraversals()方法会在measure结束后继续执行，并调用View的layout()方法来执行此过程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">host.layout(<span class="number">0</span>, <span class="number">0</span>, host.mMeasuredWidth, host.mMeasuredHeight);</div></pre></td></tr></table></figure>
<p>layout()方法接收四个参数，分别代表着左、上、右、下的坐标，当然这个坐标是相对于当前视图的父视图而言的。可以看到，这里还把刚才测量出的宽度和高度传到了layout()方法中。那么我们来看下layout()方法中的代码是什么样的吧，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> oldL = mLeft;</div><div class="line">	<span class="keyword">int</span> oldT = mTop;</div><div class="line">	<span class="keyword">int</span> oldB = mBottom;</div><div class="line">	<span class="keyword">int</span> oldR = mRight;</div><div class="line">	<span class="keyword">boolean</span> changed = setFrame(l, t, r, b);</div><div class="line"><span class="keyword">if</span> (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;</div><div class="line">	<span class="keyword">if</span> (ViewDebug.TRACE_HIERARCHY) &#123;</div><div class="line">	ViewDebug.trace(<span class="keyword">this</span>, ViewDebug.HierarchyTraceType.ON_LAYOUT);</div><div class="line">&#125;</div><div class="line">	onLayout(changed, l, t, r, b);</div><div class="line">	mPrivateFlags &amp;= ~LAYOUT_REQUIRED;</div><div class="line"><span class="keyword">if</span> (mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">	ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">	(ArrayList&lt;OnLayoutChangeListener&gt;) 							mOnLayoutChangeListeners.clone();</div><div class="line">	<span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">	listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	mPrivateFlags &amp;= ~FORCE_LAYOUT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在layout()方法中，首先会调用setFrame()方法来判断视图的大小是否发生过变化，以确定有没有必要对当前的视图进行重绘，同时还会在这里把传递过来的四个参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量。接下来会在第11行调用onLayout()方法，正如onMeasure()方法中的默认行为一样，也许你已经迫不及待地想知道onLayout()方法中的默认行为是什么样的了。进入onLayout()方法，这是个空方法，一行代码都没有？！</p>
<p>没错，View中的onLayout()方法就是一个空方法，因为onLayout()过程是为了确定视图在布局中所在的位置，而这个操作应该是由布局来完成的，即父视图决定子视图的显示位置。既然如此，我们来看下ViewGroup中的onLayout()方法是怎么写的吧，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</div></pre></td></tr></table></figure>
<p>可以看到，ViewGroup中的onLayout()方法竟然是一个抽象方法，这就意味着所有ViewGroup的子类都必须重写这个方法。没错，像LinearLayout、RelativeLayout等布局，都是重写了这个方法，然后在内部按照各自的规则对子视图进行布局的。这里我们尝试自定义一个布局，借此来更深刻地理解onLayout()的过程。自定义的这个布局目标很简单，只要能够包含一个子视图，并且让子视图正常显示出来就可以了。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleLayout</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SimpleLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context, attrs);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">		<span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;</div><div class="line">			View childView = getChildAt(<span class="number">0</span>);</div><div class="line">			measureChild(childView, widthMeasureSpec, heightMeasureSpec);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;</div><div class="line">			View childView = getChildAt(<span class="number">0</span>);</div><div class="line">			childView.layout(<span class="number">0</span>, <span class="number">0</span>, childView.getMeasuredWidth(), childView.getMeasuredHeight());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码非常的简单，我们来看下具体的逻辑吧。你已经知道，onMeasure()方法会在onLayout()方法之前调用，因此这里在onMeasure()方法中判断SimpleLayout中是否有包含一个子视图，如果有的话就调用measureChild()方法来测量出子视图的大小。接着在onLayout()方法中同样判断SimpleLayout是否有包含一个子视图，然后调用这个子视图的layout()方法来确定它在SimpleLayout布局中的位置，这里传入的四个参数依次是0、0、childView.getMeasuredWidth()和childView.getMeasuredHeight()，分别代表着子视图在SimpleLayout中左上右下四个点的坐标。其中，调用childView.getMeasuredWidth()和childView.getMeasuredHeight()方法得到的值就是在onMeasure()方法中测量出的宽和高。这样就已经把SimpleLayout这个布局定义好了，下面就是在XML文件中使用它了，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">com.example.viewtest.SimpleLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line"><span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line"><span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</div><div class="line">	</div><div class="line"><span class="tag">&lt;<span class="name">ImageView</span> </span></div><div class="line"><span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line"><span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line"><span class="attr">android:src</span>=<span class="string">"@drawable/ic_launcher"</span></div><div class="line">/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">com.example.viewtest.SimpleLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以看到，我们能够像使用普通的布局文件一样使用SimpleLayout，只是注意它只能包含一个子视图，多余的子视图会被舍弃掉。这里SimpleLayout中包含了一个ImageView，并且ImageView的宽高都是wrap_content。</p>
<p>在onLayout()过程结束后，我们就可以调用getWidth()方法和getHeight()方法来获取视图的宽高了。那么，getWidth()方法和getMeasureWidth()方法到底有什么区别呢？它们的值好像永远都是相同的。其实它们的值之所以会相同基本都是因为布局设计者的编码习惯非常好，实际上它们之间的差别还是挺大的。</p>
<p>首先getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法要在layout()过程结束后才能获取到。另外，getMeasureWidth()方法中的值是通过setMeasuredDimension()方法来进行设置的，而getWidth()方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</p>
<p>观察SimpleLayout中onLayout()方法的代码，这里给子视图的layout()方法传入的四个参数分别是0、0、childView.getMeasuredWidth()和childView.getMeasuredHeight()，因此getWidth()方法得到的值就是childView.getMeasuredWidth() - 0 = childView.getMeasuredWidth() ，所以此时getWidth()方法和getMeasuredWidth() 得到的值就是相同的，但如果你将onLayout()方法中的代码进行如下修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span>) &#123;</div><div class="line">		View childView = getChildAt(<span class="number">0</span>);</div><div class="line">		childView.layout(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样getWidth()方法得到的值就是200 - 0 = 200，不会再和getMeasuredWidth()的值相同了。当然这种做法充分不尊重measure()过程计算出的结果，通常情况下是不推荐这么写的。getHeight()与getMeasureHeight()方法之间的关系同上，就不再重复分析了。</p>
<ul>
<li>onDraw()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>measure和layout的过程都结束后，接下来就进入到draw的过程了。同样，根据名字你就能够判断出，在这里才真正地开始对视图进行绘制。ViewRoot中的代码会继续执行并创建出一个Canvas对象，然后调用View的draw()方法来执行具体的绘制工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (ViewDebug.TRACE_HIERARCHY) &#123;</div><div class="line">	    ViewDebug.trace(<span class="keyword">this</span>, ViewDebug.HierarchyTraceType.DRAW);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;&amp;</div><div class="line">	        (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</div><div class="line">	mPrivateFlags = (privateFlags &amp; ~DIRTY_MASK) | DRAWN;</div><div class="line">	<span class="comment">// Step 1, draw the background, if needed</span></div><div class="line">	<span class="keyword">int</span> saveCount;</div><div class="line">	<span class="keyword">if</span> (!dirtyOpaque) &#123;</div><div class="line">	    <span class="keyword">final</span> Drawable background = mBGDrawable;</div><div class="line">	    <span class="keyword">if</span> (background != <span class="keyword">null</span>) &#123;</div><div class="line">	        <span class="keyword">final</span> <span class="keyword">int</span> scrollX = mScrollX;</div><div class="line">	        <span class="keyword">final</span> <span class="keyword">int</span> scrollY = mScrollY;</div><div class="line">	        <span class="keyword">if</span> (mBackgroundSizeChanged) &#123;</div><div class="line">	            background.setBounds(<span class="number">0</span>, <span class="number">0</span>,  mRight - mLeft, mBottom - mTop);</div><div class="line">	            mBackgroundSizeChanged = <span class="keyword">false</span>;</div><div class="line">	        &#125;</div><div class="line">	        <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;</div><div class="line">	            background.draw(canvas);</div><div class="line">	        &#125; <span class="keyword">else</span> &#123;</div><div class="line">	            canvas.translate(scrollX, scrollY);</div><div class="line">	            background.draw(canvas);</div><div class="line">	            canvas.translate(-scrollX, -scrollY);</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">	<span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</div><div class="line">	<span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</div><div class="line">	    <span class="comment">// Step 3, draw the content</span></div><div class="line">	    <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</div><div class="line">	    <span class="comment">// Step 4, draw the children</span></div><div class="line">	    dispatchDraw(canvas);</div><div class="line">	    <span class="comment">// Step 6, draw decorations (scrollbars)</span></div><div class="line">	    onDrawScrollBars(canvas);</div><div class="line">	    <span class="comment">// we're done...</span></div><div class="line">	    <span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，第一步是从第9行代码开始的，这一步的作用是对视图的背景进行绘制。这里会先得到一个mBGDrawable对象，然后根据layout过程确定的视图位置来设置背景的绘制区域，之后再调用Drawable的draw()方法来完成背景的绘制工作。</p>
<p>那么这个mBGDrawable对象是从哪里来的呢？其实就是在XML中通过android:background属性设置的图片或颜色。当然你也可以在代码中通过setBackgroundColor()、setBackgroundResource()等方法进行赋值。</p>
<p>接下来的第三步是在第34行执行的，这一步的作用是对视图的内容进行绘制。可以看到，这里去调用了一下onDraw()方法，那么onDraw()方法里又写了什么代码呢？进去一看你会发现，原来又是个空方法啊。其实也可以理解，因为每个视图的内容部分肯定都是各不相同的，这部分的功能交给子类来去实现也是理所当然的。</p>
<p>第三步完成之后紧接着会执行第四步，这一步的作用是对当前视图的所有子视图进行绘制。但如果当前的视图没有子视图，那么也就不需要进行绘制了。因此你会发现View中的dispatchDraw()方法又是一个空方法，而ViewGroup的dispatchDraw()方法中就会有具体的绘制代码。以上都执行完后就会进入到第六步，也是最后一步，这一步的作用是对视图的滚动条进行绘制。那么你可能会奇怪，当前的视图又不一定是ListView或者ScrollView，为什么要绘制滚动条呢？其实不管是Button也好，TextView也好，任何一个视图都是有滚动条的，只是一般情况下我们都没有让它显示出来而已。绘制滚动条的代码逻辑也比较复杂，这里就不再贴出来了，因为我们的重点是第三步过程。</p>
<p>通过以上流程分析，相信大家已经知道，View是不会帮我们绘制内容部分的，因此需要每个视图根据想要展示的内容来自行绘制。如果你去观察TextView、ImageView等类的源码，你会发现它们都有重写onDraw()这个方法，并且在里面执行了相当不少的绘制逻辑。绘制的方式主要是借助Canvas这个类，它会作为参数传入到onDraw()方法中，供给每个视图使用。Canvas这个类的用法非常丰富，基本可以把它当成一块画布，在上面绘制任意的东西。这里简单起见，创建一个非常简单的视图，并且用Canvas随便绘制一点东西，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Paint mPaint;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context, attrs);</div><div class="line">		mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">		mPaint.setColor(Color.YELLOW);</div><div class="line">		canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), mPaint);</div><div class="line">		mPaint.setColor(Color.BLUE);</div><div class="line">		mPaint.setTextSize(<span class="number">20</span>);</div><div class="line">		String text = <span class="string">"Hello View"</span>;</div><div class="line">		canvas.drawText(text, <span class="number">0</span>, getHeight() / <span class="number">2</span>, mPaint);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们创建了一个自定义的MyView继承自View，并在MyView的构造函数中创建了一个Paint对象。Paint就像是一个画笔一样，配合着Canvas就可以进行绘制了。这里我们的绘制逻辑比较简单，在onDraw()方法中先是把画笔设置成黄色，然后调用Canvas的drawRect()方法绘制一个矩形。然后在把画笔设置成蓝色，并调整了一下文字的大小，然后调用drawText()方法绘制了一段文字。就这么简单，一个自定义的视图就已经写好了，现在可以在XML中加入这个视图，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line"><span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line"><span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">com.example.viewtest.MyView</span> </span></div><div class="line"><span class="attr">android:layout_width</span>=<span class="string">"200dp"</span></div><div class="line"><span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></div><div class="line">/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>Android 中实现 View 的更新有两种方法，一种是invalidate，另一种是postInvalidate，其中前者是在UI线程自身中使用，而后者在非UI线程中使用。</strong></p>
<ul>
<li>invalidate()</li>
</ul>
<p>View 本身调用迫使 View 重画，在 UI 线程中自身使用，不能直接在线程中调用，如果要使用该方法进行刷新，则我们就需要配合 Handler 。</p>
<ul>
<li>postInvalidate()</li>
</ul>
<p>与上述方法功能一致，但是不用与 Handler 结合，可以直接在线程中调用。</p>
<ul>
<li>requestLayout()</li>
</ul>
<p>当view确定自身已经不再适合现有的区域时，该view本身调用这个方法要求parent view（父类的视图）重新调用他的onMeasure onLayout来重新设置自己位置。特别是当view的layoutparameter发生改变，并且它的值还没能应用到view上时，这时候适合调用这个方法。</p>
<h2 id="自定义-View"><a href="#自定义-View" class="headerlink" title="自定义 View"></a>自定义 View</h2><p>在实际开发中，要做出一些绚丽的界面效果如果仅仅靠系统的控件是远远不够的。这个时候就必须通过自定义 View 来实现这些特定的效果。自定义 View 是一个综合的技术体系，它涉及 View 的层次结构，事件分发机制和 View 的工作原理等技术细节。</p>
<p><strong>自定义View绘制流程函数调用链</strong> </p>
<p><img src="/Users/hywel/Desktop/005Xtdi2jw1f638wreu74j30fc0heaay.jpg" alt="005Xtdi2jw1f638wreu74j30fc0heaay"></p>
<h3 id="自定义-View-的分类"><a href="#自定义-View-的分类" class="headerlink" title="自定义 View 的分类"></a>自定义 View 的分类</h3><p>自定义 View 的分类标准不唯一，可以简单分为4类。</p>
<ol>
<li><p>继承 View 重写 onDraw 方法</p>
<p>这种方法主要用于实现一些不规则的效果，即这种效果不方便通过布局的组合方式来达到，往往需要静态或者动态地显示一些不规则的图形。很显然这需要通过绘制的方式来实现，即重写 onDraw 方法。使用这种方式需要自己支持 wrap_content，并且 padding 也需要自己处理。</p>
</li>
<li><p>继承 ViewGroup 派生特殊的 Layout</p>
<p>这种方法主要用于实现自定义布局，即除了 LinearLayout、RelativeLayout、FrameLayout 这几种系统的布局之外，我们可以重新定义一种新布局，当某种效果看起来很像几种 View 组合在一起的时候，可以采用这种方法来实现。采用这种方式稍微复杂一些，需要合适地处理 ViewGroup 的测量、布局这两个过程，并同时处理子元素的测量和布局处理。</p>
</li>
<li><p>继承特定的 View（比如 TextView）</p>
<p>这种方法比较常见，一般用于扩展某种已有的 View 的功能，比如 TextView，这种方法比较容易实现。这种方法不需要自己支持 wrap_content 和 padding 等。</p>
</li>
<li><p>继承特定的 ViewGroup（比如 LinearLayout）</p>
<p>这种方法也比较常见，当某种效果看起来很像几种 View 组合在一起的时候，可以采用这种方法来实现。采用这种方法不需要自己处理 ViewGroup 的测量和布局这两个过程。需要注意和方法2的区别，一般方法2能实现的效果方法4也能实现，两者主要差别在于方法2更接近 View 底层。</p>
</li>
</ol>
<p>自定义 View 讲究的是灵活性，一种效果可能有很多方法都能实现，我们需要做的就是找到一种代价最小、最高效的方法来实现。</p>
<h3 id="自定义-View-须知"><a href="#自定义-View-须知" class="headerlink" title="自定义 View 须知"></a>自定义 View 须知</h3><p>一些自定义 View 过程中的注意事项，如果处理不好，则可能会影响 View 的正常使用。</p>
<ol>
<li><p>让 View 支持 wrap_content</p>
<p>直接继承 View 或者 ViewGroup 的控件，如果不在 onMeasure 中对 wrap_content 做特殊处理，那么当外界在布局中使用wrap_content时就无法达到预期的效果。</p>
</li>
<li><p>如果有必要，让你的 View 支持padding</p>
<p>直接继承 View 的控件，如果不在 draw 方法中处理 padding，那么padding属性是无法起作用的。另外，直接继承自 ViewGroup 的控件需要在 onMeasure 和 onLayout 中考虑padding和子元素的 margin 对其造成的影响，不然将导致padding和子元素的 margin 失效。</p>
</li>
<li><p>尽量不要在 View 中使用 Handler，不必要</p>
<p>View 内部就提供了 post 系列的方法，完全可以替代 Handler 的作用，当然除非你很明确地要使用 Handler 来发送信息。</p>
</li>
<li><p>View 中如果有线程或者动画，需要及时停止</p>
<p>如果有线程或者动画需要停止时，那么 onDetachedFromWindow 是一个很好的时机。当包含此 View 的 Activity 退出或者当前 View 被 remove 时，View 的onDetachedFromWindow方法会被调用，和此方法对应的是 onAttachedToWindow，当包含此 View 的 Activity 启动时，View 的onAttachedToWindow方法会被调用。同时，当 View 变得不可见时我们也需要停止线程和动画，如果不及时处理这种问题，有可能会造成内存泄漏。</p>
</li>
<li><p>View 带有滑动嵌套情形时，需要处理好滑动冲突</p>
<p>如果有滑动冲突的话，那么要合适地处理滑动冲突，否则将会严重影响 View 的效果。</p>
</li>
</ol>
<h3 id="自定义-View-的坐标系"><a href="#自定义-View-的坐标系" class="headerlink" title="自定义 View 的坐标系"></a>自定义 View 的坐标系</h3><ul>
<li><p>注意屏幕坐标系和数学坐标系的区别</p>
<p>移动设备一般定义屏幕的左上角为坐标原点，向右为 x 轴增大方向，向下为 y 轴的增大方向。如下所示：</p>
<p><strong>PS：其中的∠a 是对应的，注意y轴方向！</strong></p>
<p>​</p>
<p> <img src="/Users/hywel/Desktop/005Xtdi2jw1f1qygzfvhoj308c0dwglr.jpg" alt="005Xtdi2jw1f1qygzfvhoj308c0dwglr"></p>
<pre><code>![005Xtdi2jw1f1qyhbqvihj308c0dwjrh](/Users/hywel/Desktop/005Xtdi2jw1f1qyhbqvihj308c0dwjrh.jpg)
</code></pre></li>
</ul>
<p>实际屏幕上的默认坐标系如下：</p>
<blockquote>
<p>假设其中的棕色部分为手机屏幕</p>
</blockquote>
<p>​         <img src="/Users/hywel/Desktop/005Xtdi2jw1f1qyhjy7h8j308c0dwq32.jpg" alt="005Xtdi2jw1f1qyhjy7h8j308c0dwq32"></p>
<ul>
<li><p>View 的坐标系</p>
<p><strong>View 的坐标系是相对于父控件而言的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">getTop();       <span class="comment">//获取子View左上角距父View顶部的距离</span></div><div class="line">getLeft();      <span class="comment">//获取子View左上角距父View左侧的距离</span></div><div class="line">getBottom();    <span class="comment">//获取子View右下角距父View顶部的距离</span></div><div class="line">getRight();     <span class="comment">//获取子View右下角距父View左侧的距离</span></div></pre></td></tr></table></figure>
<p> <img src="/Users/hywel/Desktop/005Xtdi2gw1f1qzqwvkkbj308c0dwgm9.jpg" alt="005Xtdi2gw1f1qzqwvkkbj308c0dwgm9"></p>
</li>
</ul>
<ul>
<li><p>MotionEvent中 get 和 getRaw 的区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">event.getX();       <span class="comment">//触摸点相对于其所在组件坐标系的坐标</span></div><div class="line">event.getY();</div><div class="line"></div><div class="line">event.getRawX();    <span class="comment">//触摸点相对于屏幕默认坐标系的坐标</span></div><div class="line">event.getRawY();</div></pre></td></tr></table></figure>
<p><strong>其中相同颜色的内容是对应的，其中为了显示方便，蓝色箭头向左稍微偏移了一点.</strong></p>
<p> <img src="/Users/hywel/Desktop/005Xtdi2jw1f1r2bdlqhbj308c0dwwew.jpg" alt="005Xtdi2jw1f1r2bdlqhbj308c0dwwew"></p>
</li>
</ul>
<h3 id="自定义-View-事件处理"><a href="#自定义-View-事件处理" class="headerlink" title="自定义 View 事件处理"></a>自定义 View 事件处理</h3><p>在自定义 View 的过程中，经常要处理一些View事件相关的东西。比如 Touch 事件，下面做简单描述：</p>
<ul>
<li><p>Touch 事件传递规则分析</p>
<p>Touch 事件是包装在 MotionEvent 对象中的，在手指与屏幕接触的过程中产生一系列事件，比较典型的是以下三种：</p>
<ul>
<li>ACTION_DOWN: 手指刚接触屏幕的瞬间</li>
<li>ACTION_UP: 手指刚离开屏幕的瞬间</li>
<li>ACTION_MOVE: 手指在屏幕上滑动</li>
</ul>
</li>
</ul>
<font color="green"><strong>事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</strong></font>

<p>Touch事件发生时Activity的dispatchTouchEvent(MotionEvent ev)方法会将事件传递给最外层View的dispatchTouchEvent(MotionEvent ev)方法，该方法对事件进行分发。分发逻辑如下：</p>
<pre><code>如果return true，事件会由当前View的dispatchTouchEvent方法进行消费，同时事件会停止向下传递；

如果return false，事件分发分为两种情况：

    如果当前 View 获取的事件直接来自 Activity，则会将事件返回给Activity的onTouchEvent进行消费；

    如果当前 View 获取的事件来自外层父控件，则会将事件返回给父View的onTouchEvent进行消费。

如果return super.dispatchTouchEvent(ev)，事件会自动的分发给当前View的onInterceptTouchEvent方法。
</code></pre><font color="green"><strong>事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</strong></font>

<p>正如上面所说，如果在dispatchTouchEvent返回super.dispatchTouchEvent(ev)，那么事件将会传递到onInterceptTouchEvent方法，该方法对事件进行拦截。拦截逻辑如下：</p>
<p>​    如果return true,则表示拦截该事件，并将事件传递给当前 View 的 onTouchEvent 方法；</p>
<p>​    如果 return false,则表示不拦截该事件，并将该事件交由子 View的dispatchTouchEvent方法进行事件分发，重复上述过程；</p>
<p>​    如果 return super.onInterceptTouchEvent(ev)，默认表示拦截该事件，并将事件传递给当前 View 的onTouchEvent方法，和 return true 一样。</p>
<font color="green"><strong>事件响应：public boolean onTouchEvent(MotionEvent ev)</strong></font>

<p>上面已经提到，在dispatchTouchEvent（事件分发）返回super.dispatchTouchEvent(ev)并且onInterceptTouchEvent（事件拦截返回true或super.onInterceptTouchEvent(ev)的情况下，那么事件会传递到onTouchEvent方法，该方法对事件进行响应。响应逻辑如下：</p>
<p>如果return true，则表示响应并消费该事件；</p>
<p>如果return fasle，则表示不响应事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的onTouchEvent进行处理；</p>
<p>如果return super.dispatchTouchEvent(ev)，则表示不响应事件，结果与return false一样。<br>这里也顺便说一下，如果一个View同时监听了onTouch事件和onClick事件，则在onTouchEvent里面应该返回false，否则点击事件就无法监听到。</p>
<h3 id="自定义-View滑动冲突处理"><a href="#自定义-View滑动冲突处理" class="headerlink" title="自定义 View滑动冲突处理"></a>自定义 View滑动冲突处理</h3><p>滑动冲突多出现在滑动嵌套的场景，比如一个界面里可能有两个或两个以上的 View 同时可以滑动，那么就可能导致只有一个 View 可以滑动。一个简单的屏幕触摸动作触发了一系列 Touch 事件：ACTION_DOWN-&gt;ACTION_MOVE-&gt;ACTION_MOVE-&gt;ACTION_MOVE…-&gt;ACTION_UP。</p>
<p>滑动冲突的场景主要有三种：</p>
<ol>
<li><p>一个页面中同时存在左右滑动和上下滑动</p>
<p>让外部的 View 拦截滑动事件，判断滑动的特征。如果水平滑动距离&gt;竖直滑动距离，则为水平滑动，反之为竖直滑动。假设内部 View 可以水平滑动，而外部 View 可以竖直滑动，那么在外部 View 的onInterceptTouchEvent()方法判断，如果触摸事件为水平滑动，则应该返回 false，交由内部 View来处理，这样内部的子 View 就可以实现水平滑动。</p>
</li>
<li><p>同时存在两个竖直或水平滑动</p>
<p>这种情况下还主要得根据具体的需求分析。最简单的就是假如两个 ScrollView 嵌套，一般可以判断 ACTION_DOWN在哪个 View 上，就执行哪个 View 的滑动事件。</p>
</li>
<li><p>上面1和2同时存在的情况</p>
<p>根据具体业务需求和滑动策略来处理。</p>
</li>
</ol>
<h3 id="自定义-View-示例"><a href="#自定义-View-示例" class="headerlink" title="自定义 View 示例"></a>自定义 View 示例</h3><p> <img src="/Users/hywel/Desktop/CustomView.png" alt="CustomView"></p>
<h4 id="简单的导航栏（复合式自定义-View-类型）"><a href="#简单的导航栏（复合式自定义-View-类型）" class="headerlink" title="简单的导航栏（复合式自定义 View 类型）"></a>简单的导航栏（复合式自定义 View 类型）</h4><blockquote>
<p>复合式自定义View就是将我们平时用到一些单个的view组合起来，并对该组合控件进行属性自定义、暴露交互接口等，来实现我们的复合式自定义view。</p>
</blockquote>
<p>项目中，经常需要用到导航栏，为了统一样式方便利用。做一个简单的导航栏示例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomNaviBar</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Context mContext;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> View rootView;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Left navigator button</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Button mLeftButton;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Right navigator button</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Button mRightButton;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Central title text</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> TextView mTitleTextView;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Navigator area</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> RelativeLayout mNaviLayout;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomNaviBar</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</div><div class="line">        mContext = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomNaviBar</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        mContext = context;</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//通过 layout 资源引用</span></div><div class="line">        rootView = LayoutInflater.from(mContext).inflate(R.layout.custom_navibar_layout, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">        mNaviLayout = (RelativeLayout) rootView.findViewById(R.id.navi_bg);</div><div class="line">        mLeftButton = (Button) rootView.findViewById(R.id.left_btn);</div><div class="line">        mLeftButton.</div><div class="line">  setOnClickListener(mLeftButtonClickListener);</div><div class="line">        </div><div class="line">  		mRightButton = (Button) rootView.findViewById(R.id.right_btn);</div><div class="line"> 		mRightButton.              setOnClickListener(mRightButtonClickListener);</div><div class="line">        mTitleTextView = (TextView) rootView.findViewById(R.id.title_text);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">   <span class="keyword">private</span> OnClickListener mLeftButtonClickListener = <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            Toast.makeText(mContext, <span class="string">"Back!"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> OnClickListener mRightButtonClickListener = <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            Toast.makeText(mContext, <span class="string">"Menu!"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">  <span class="comment">/**</span></div><div class="line">     * 设置导航栏背景色</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> colorString</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNaviLayouBackground</span><span class="params">(String colorString)</span> </span>&#123;</div><div class="line">        mNaviLayout.setBackgroundColor(Color.parseColor(colorString));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置标题</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> title</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitleText</span><span class="params">(String title)</span> </span>&#123;</div><div class="line">        mTitleTextView.setText(title);</div><div class="line">    &#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">     * 设置标题是否显示</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> isShow</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitleVisibility</span><span class="params">(<span class="keyword">boolean</span> isShow)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isShow) &#123;</div><div class="line">            mTitleTextView.setVisibility(View.VISIBLE);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mTitleTextView.setVisibility(View.GONE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置左侧按钮文案</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> title</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftButtonText</span><span class="params">(String title)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(title)) &#123;</div><div class="line">            mLeftButton.setVisibility(View.INVISIBLE);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        mLeftButton.setText(title);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置左侧按钮是否显示</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> isShow</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftButtonVisibility</span><span class="params">(<span class="keyword">boolean</span> isShow)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isShow) &#123;</div><div class="line">            mLeftButton.setVisibility(View.VISIBLE);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mLeftButton.setVisibility(View.GONE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置右侧按钮文案</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> title</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightButtonText</span><span class="params">(String title)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(title)) &#123;</div><div class="line">            mRightButton.setVisibility(View.INVISIBLE);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        mRightButton.setText(title);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置右侧按钮是否显示</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> isShow</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightButtonVisibility</span><span class="params">(<span class="keyword">boolean</span> isShow)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isShow) &#123;</div><div class="line">            mRightButton.setVisibility(View.VISIBLE);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mRightButton.setVisibility(View.GONE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，也可以通过在 values/attr 下面定义 styleable 属性来自定义本 View</p>
<h4 id="计数-View（完全自定义-View-类型）"><a href="#计数-View（完全自定义-View-类型）" class="headerlink" title="计数 View（完全自定义 View 类型）"></a>计数 View（完全自定义 View 类型）</h4><blockquote>
<p>完全自定义式的自定义View就是通过重写View来实现一些全新控件。</p>
</blockquote>
<p>自定义 View实现一个点击计数的 View 视图。它集成自View，重写了 onDraw 方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterView</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</div><div class="line">	<span class="comment">//画笔</span></div><div class="line">    <span class="keyword">private</span> Paint paint;</div><div class="line">	<span class="comment">//矩形</span></div><div class="line">    <span class="keyword">private</span> Rect rect;</div><div class="line">	<span class="comment">//次数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line"></div><div class="line">        paint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">        rect = <span class="keyword">new</span> Rect();</div><div class="line">        setOnClickListener(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        count++;</div><div class="line">        invalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">		paint.           setColor(Color.parseColor(<span class="string">"#a0d00d"</span>));</div><div class="line">        canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), paint);</div><div class="line">        paint.setColor(Color.YELLOW);</div><div class="line">        paint.setTextSize(<span class="number">50</span>);</div><div class="line">        String text = String.valueOf(count);</div><div class="line">        paint.getTextBounds(text, <span class="number">0</span>, text.length(), rect);</div><div class="line">        <span class="keyword">float</span> width = rect.width();</div><div class="line">        <span class="keyword">float</span> height = rect.height();</div><div class="line">        canvas.drawText(text, getWidth() / <span class="number">2</span> - width / <span class="number">2</span>, getHeight() / <span class="number">2</span> + height / <span class="number">2</span>, paint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="闪光-TextView（扩展式自定义-View-类型）"><a href="#闪光-TextView（扩展式自定义-View-类型）" class="headerlink" title="闪光 TextView（扩展式自定义 View 类型）"></a>闪光 TextView（扩展式自定义 View 类型）</h4><blockquote>
<p>扩展式自定义View就是通过继承现有的控件并更改一些功能或效果来实现的一种自定义View。</p>
</blockquote>
<p>本 View 继承自TextView，实现不断闪光的效果。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiningTextView</span> <span class="keyword">extends</span> <span class="title">TextView</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> mViewWidth;</div><div class="line"></div><div class="line">    LinearGradient mLinearGradient;</div><div class="line"></div><div class="line">    Matrix mMatrix;</div><div class="line"></div><div class="line">    Paint mPaint;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mTranslate = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShiningTextView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line"><span class="comment">//        Log.i("xhw", "onSizeChanged-----&gt;");</span></div><div class="line"></div><div class="line">        <span class="comment">// 在 onSizeChanged 方法中获取到宽度，并对各个类进行初始化</span></div><div class="line">        <span class="keyword">if</span> (mViewWidth == <span class="number">0</span>) &#123;</div><div class="line">            mViewWidth = getMeasuredWidth();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mViewWidth &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 得到父类 TextView 中写字的那支笔</span></div><div class="line">                mPaint = getPaint();</div><div class="line">                <span class="comment">// 初始化线性渲染器</span></div><div class="line">                mLinearGradient = <span class="keyword">new</span> LinearGradient(<span class="number">0</span>, <span class="number">0</span>, mViewWidth, <span class="number">0</span>, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</div><div class="line">                        Color.BLUE, Color.YELLOW, Color.RED, Color.GREEN</div><div class="line">                &#125;, <span class="keyword">null</span>, Shader.TileMode.CLAMP);</div><div class="line">                <span class="comment">// 把渲染器给笔套上</span></div><div class="line">                mPaint.setShader(mLinearGradient);</div><div class="line">                <span class="comment">// 初始化 Matrix</span></div><div class="line">                mMatrix = <span class="keyword">new</span> Matrix();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="comment">// 先让父类方法执行，由于上面我们给父类的 Paint 套上了渲染器，所以这里出现的文字已经是彩色的了</span></div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"><span class="comment">//        Log.i("xhw", "onDraw-----&gt;");</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mMatrix != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 利用 Matrix 的平移动作实现霓虹灯的效果，这里是每次滚动1/10</span></div><div class="line">            mTranslate += mViewWidth / <span class="number">10</span>;</div><div class="line">            <span class="comment">// 如果滚出了控件边界，就要拉回来重置开头，这里重置到了屏幕左边的空间</span></div><div class="line">            <span class="keyword">if</span> (mTranslate &gt; mViewWidth) &#123;</div><div class="line">                mTranslate = -mViewWidth / <span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 设置平移距离</span></div><div class="line">            mMatrix.setTranslate(mTranslate, <span class="number">0</span>);</div><div class="line">            <span class="comment">// 平移效果生效</span></div><div class="line">            </div><div class="line">          mLinearGradient.setLocalMatrix(mMatrix);</div><div class="line">            <span class="comment">// 延迟 100 毫秒再次刷新 View 也就是再次执行本 onDraw 方法</span></div><div class="line">            postInvalidateDelayed(<span class="number">100</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/18/自定义View的简单总结/" data-id="cixndbiyy000k3fs6n9xjzq00" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/01/06/Hexo安装过程简单总结/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hexo安装过程简单总结
        
      </div>
    </a>
  
  
    <a href="/2016/08/04/Andoird优化VS内存优化/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android优化VS内存优化</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/coding/">coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/coding-note/">coding,note</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Other/">Other</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Other/" style="font-size: 10px;">Other</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/06/Hexo安装过程简单总结/">Hexo安装过程简单总结</a>
          </li>
        
          <li>
            <a href="/2016/08/18/自定义View的简单总结/">自定义View的简单总结</a>
          </li>
        
          <li>
            <a href="/2016/08/04/Andoird优化VS内存优化/">Android优化VS内存优化</a>
          </li>
        
          <li>
            <a href="/2016/08/04/如何在-Android-中避免创建不必要的对象/">如何在 Android 中避免创建不必要的对象</a>
          </li>
        
          <li>
            <a href="/2016/08/04/如何选择-compileSdkVersion-minSdkVersion-和-targetSdkVersion/">如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Hywel Xu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">目录</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>